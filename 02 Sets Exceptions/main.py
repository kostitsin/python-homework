# МАТЧАСТЬ
# множества - тип данных, который позволяет быстро сравнивать наборы элементов очень большого размера. Множества оптимизирует сам питон, поэтому доступа по индексу и порядка элементов, как в списке, там нет. Также множество может содержать только уникальные эначения (вспомните ключи словаря)
# множества https://pythonworld.ru/tipy-dannyx-v-python/mnozhestva-set-i-frozenset.html
# диаграмма Венна https://ru.wikipedia.org/wiki/Диаграмма_Венна
# очень понятная визуализация теории множеств :) https://static.tildacdn.com/tild3761-6332-4239-a166-306134646164/20180123_084944.png

# Исключение -
# описание типов исключений и пример работы с ними https://pythonworld.ru/tipy-dannyx-v-python/isklyucheniya-v-python-konstrukciya-try-except-dlya-obrabotki-isklyuchenij.html

import csv

flats_list = list()

with open('output.csv', encoding="utf-8") as csvfile:
    flats_csv = csv.reader(csvfile, delimiter=';')
    flats_list = list(flats_csv)

header = flats_list.pop(0)

print("=== МНОЖЕСТВА ===")
# узнаем при помощи множеств, сколько у нас различных метро в выгрузке
subway_set = set() # создаем множество
for flat in flats_list:
    subway = flat[3].replace("м.", "")
    if len(subway) > 0: # пустое метро не добавляем
        subway_set.add(subway) # добавляем станцию метро в множество. Если она там уже есть, добавления не происходит
print(f"Всего у нас {len(subway_set)} станций метро:\n {subway_set}")

# пусть у нас есть несколько станций метро, рядом с которыми мы хотим найти квартиру. Проверим, есть ли какие-то из них в выгрузке с ЦИАНа, при помощи пересечения множеств
test_set = set(["Перово", "Новогиреево", "Выхино"])
print()
print(f"Пересечение множеств: \n{subway_set & test_set}")
print(f"Пересечение множеств: \n{subway_set.intersection(test_set)}") # то же самое

# найдем метро из первого множества, которых нет во втором. Обратите внимание, что здесь уже играет значение, для какого множества мы вызываем функцию
print()
print(f"Выводим уникальные элементы (difference): \n{test_set.difference(subway_set)}")
print(f"Выводим уникальные элементы (difference): \n{subway_set.difference(test_set)}") # результат будет другим
print(f"Сравним, одинаковы ли результаты двух вариантов difference:\n{test_set.difference(subway_set) == subway_set.difference(test_set)}")

# найдем метро, которые есть только в одном множестве (т.е. исключим общий элемент "Выхино")
print()
print(f"Выводим уникальные элементы (symmetric_difference): \n{test_set.symmetric_difference(subway_set)}")
print(f"Выводим уникальные элементы (symmetric_difference): \n{subway_set.symmetric_difference(test_set)}") # резульат будет другим
print(f"Сравним, одинаковы ли результаты двух вариантов symmetric_difference:\n{test_set.symmetric_difference(subway_set) == subway_set.symmetric_difference(test_set)}")

# РАБОТА С ИСКЛЮЧЕНИЯМИ
print()
print("=== ИСКЛЮЧЕНИЯ - assert ===")
# при помощи функции assert мы можем проверить, выполняется ли какое-либо условие. В отличие от простой проверки вида if "Черкизовская" in test_set, которая вернет False, функция assert сгенерирует исключение, если условие не выполнится (результат False)
assert "Перово" in test_set # не будет исключения, т.к. метро "Перово" есть в множестве test_set
# assert "Черкизовская" in test_set # будет исключение, т.к. метро "Черкизовская" нет в множестве test_set

# чтобы код в строке 46 перестал падать, нужно переписать команду, добавив блок обработки исключений try .. except
try:
    assert "Черкизовская" in test_set  # будет исключение, т.к. метро "Черкизовская" нет в множестве test_set
except:
    print("Теперь мы умеем генерировать исключения")

print()
print("=== ИСКЛЮЧЕНИЯ - try .. except ===")
# полностью синтаксис работы с исключениями выглядит так:
# в блок try убирайте ваш потенциально небезопасный код
try:
    print("Здесь код, который может вызвать исключения")
    # генерируем исключение вручную, чтобы увидеть, как работает код. Если мы хотим увидеть пояснительный текст, необходимо ввести его как параметр
    raise IndexError("Это исключение IndexError, которое мы сгенерировали сами")
# например, исключение при обработке числа с плавающей точкой
except FloatingPointError as e:
    print(e)
# например, исключение "ошибка индекса", например, при работе со списками
except IndexError as e:
    print(e)
# этот блок сработает, если никаких исключений не возникло
else:
    print("Ничего не случилось")
# этот блок срабатывает всегда, не зависимо от того, было ли исключение или нет. Обратите внимание: даже если в блоке перехвата исключения была команда выхода из цикла, блок finally выполнится все равно
finally:
    print("Сработает всегда")

# исключения на примере работы с данными о квартирах
print()
budget = 3000000
while True:
    user_input = input("Введите ваш бюджет в рублях и станцию метро через запятую. Если хотите закончить, введите q\n")

    if user_input.lower() == "q":
        print(f"Благодарим за использование нашей программы!")
        break

    # пользователь должен ввести два значения через запятую. Ввод через input() - всегда строка, поэтому придется разбить ее функцией split(",")
    params = user_input.split(",")
    # в итоге у нас должно получиться два значения - бюджет будет в param[0], станция метро - в param[1]

    # если пользователь ошибся при вводе, функция int выбросит исключение, поэтому лучше предусмотреть проверку
    try:
        budget = int(params[0])
    # объект Exception перехватит исключение любого типа и сохранит информацию о нем в переменную e
    except Exception as e:
        print(f"Произошла ошибка {e}. Попробуйте еще раз")
        continue

    # альтернатива исключению здесь - проверка, может ли ввод пользователя быть преобразован в число
    # if user_input.isdigit():
    # 	budget = int(user_input)
    # else:
    # 	print("Кажется, вы ввели не число. Попробуйте еще раз")
    # 	continue

    # если невнимательный пользователь введет только одно значение, наш код упадет при попытке обработать param[1]
    # здесь есть также два варианта действий: 1) проверить количество параметров len(params) == 2 либо использовать обработку исключений
    try:
        user_subway = params[1]
    except Exception as e:
        print(f"Похоже, вы не задали второй параметр (ошибка {e}). Попробуйте еще раз")
        continue

    # выведем квартиры, которые подходят по бюджету и находятся у нужного нам метро
    # но при этом на всякий случай подсчитаем, сколько квартир вообще нам доступно по бюджету
    can_allow_count = 0
    for i, flat in enumerate(flats_list):
        subway = flat[3].replace("м.", "")
        if budget >= int(flat[11]):
            can_allow_count += 1
            if subway.lower() == user_subway.lower():
                print(f"Мы можем купить квартиру №{i+1} у метро {subway} за {flat[11]} руб")

    print(f"Всего мы можем себе позволить {can_allow_count} квартир, имея бюджет {budget} руб")

# для того, чтобы создать собственное исключение, необходимо создать класс и унаследовать его от какого-то системного исключения
print()
print("=== ИСКЛЮЧЕНИЯ - собственные исключения пользователя ===")

class MyNewException(Exception):
    print("Это сообщение из нашего класса, оно появится всегда вместе с исключением.")

try:
  raise MyNewException("Наше собственное ислючение")
except Exception as e:
  print(f"Мы поймали свое собственное исключение: {e}")