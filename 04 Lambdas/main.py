# ====================
# Часть 1: lambda-функции, функции map и filter
# ====================

# массив слов для демонстрации работы алгоритмов сортировки
word_list = ["а", "автомат", "авто", "авиа", "ар"]

# по умолчанию функция сортировки списков list.sort() сортирует элементы списка как числа - по возрастанию или убыванию,
# поэтому при сортировке строк работает следующий алгоритм: у каждой буквы в таблице символов есть свой числовой код.
# Алгоритм сортировки (сортировка по возрастанию): # 1) берет первую букву каждого слова, определяет ее код,
# 2) первым элементом в списке становится слово, начинающееся с наименьшего кода, 3) если таких слов несколько, берется следующая буква всех подходящих слов и определяется наименьший код до тех пор, пока не найдется следующее слово. Пример:
# а, автомат, авто, авиа, ар -> а | автомат, авто, авиа, ар
# автомат, авто, авиа, ар -> автомат, авто, авиа | ар ("р" 0xF0 имеет больший код, чем "в" 0xE2) -> авиа | автомат, авиа
# и т.д.

word_list.sort()
print(word_list)
# вернет: а, авиа, авто, автомат, ар. То есть длина слова не влияет на результат сортировки

# тем не менее, можно изменить поведение функции list.sort, написав собственную функцию сортировки:
# кастомная функция сортировки. Возвращает длину слова, которую и использует list.sort
def sort_by_len(word):
	return len(word)

word_list.sort(key=sort_by_len)
# вернет: а, ар, авто, авиа, автомат
print(word_list)

# того же самого результата можно добиться, не загромождая свой код простыми маленькими функциями
# lambda-функции - это функции, которые а) не имеют имени, б) создаются непосредственно в месте использования и сразу уничтожаются, в) записываются в одну строку, г) всегда возвращает значение, но без ключевого слова return

# реализация кастомной сортировки того же списка при помощи lambda-фукции
word_list.sort(key=lambda x: len(x))
# вернет: а, ар, авто, авиа, автомат
print(word_list)

# запись lambda x: len(x) эквивалентна
# def sort_by_len(word):
# 	return len(word)

# lambda-функцию можно присвоить переменной и тогда она не удалится. хотя все равно останется безымянной
sort_by_len = lambda x: len(x)
word_list.sort(key=sort_by_len)

# функцию можно удалить так же, как любой другой объект:
del sort_by_len

# для того, чтобы распространить функцию на все элементы списка, используются две функции:
# filter - фильтр по условию. Если для элемента условие True, то элемент остается в списке. Если False - элемент пропускается
# map - производит вычисление над каждым элементом списка
# обе фукнции принимают два аргумента: 1) функция для обработки, 2) переменная, содержащая данные для обработки

# создаем тестовый список numbers с числами от 0 до 99
numbers = list(range(0, 100))

# выводим только четные числа (делятся на 2 без остатка)
# вот так работает механизм, заложенный в функцию filter:
def check_even():
	for number in numbers:
		if number %2 == 0:
			return number
		else:
			return False

# пример отбора четных чисел из списка функцией filter:
even_list = list(filter(lambda x: x%2 == 0, numbers))
print(even_list)

# lambda-функцию можно запустить сразу в месте объявления. Передача параметра будет выглядеть так (проверка числа на четность):
print((lambda x: x%2 == 0)(2))

# пример вычисления над каждым элементом списка. вычисление квадратов чисел функцией map:
square_list = list(map(lambda x: x*x, numbers))
print(square_list)

# пример вычисления над каждым элементом списка. вычисление квадратов чисел функцией map с условием - обрабатываем только четные числа:
square_list = list(map(lambda x: x*x if x%2 == 0 else None, numbers))
# на месте нечетных чисел будет значение, задаваемое в условии else, т.к. функция map, в отличие от filter, не умеет пропускать значения
print(square_list)

# пример совместного использования map и filter. результатом будут все четные числа, возведенные в квадрат
square_list_filtered = list(filter(lambda x: x is not None, map(lambda x: x*x if x%2 == 0 else None, numbers)))
print(f"Совместное использование функций map и filter\n {square_list_filtered}")

# ====================
# Часть 2: генераторы списков
# ====================

# генераторы списков - специальный механизм Python, позволяющий создавать на лету новые списки как результат фильтрации или вычислений
# применяются ТОЛЬКО к типу list!
# следующее выражение даст тот же результат, что и функция filter над массивом numbers
even_list2 = [x for x in numbers if x%2 == 0]
print(even_list2)

# а это генератор - аналог функции map
even_list3 = [x if x%2 == 0 else None for x in numbers]
print(even_list3)


# ====================
# Часть 3: практическое применение: работа с текстами
# ====================

# МАТЧАСТЬ: стоп-слова - это слова, не несущие смысловой нагрузки (предлоги, союзы, местоимения, частицы), которые можно устранить без потери содержания
# водность текста - процентное содержание незначащих "стоп-слов"
# https://contentmonster.ru/ur-6-vodnost-teksta
# Водность текста 100%
# Вот это да! Как быстро все вокруг стало невероятно великолепным теперь для меня! У меня никогда больше, наверное, не будет такого, как сегодня, когда мое «Я» стало менее важным, чем что-то другое. Ещё недавно мне никто не был нужен, я хотел быть один. А теперь я могу, наконец, думать о тебе и знать, что ты для меня – самое главное. Теперь у меня есть ты, и я понимаю: лучшее, что можно сделать – это быть с тобой рядом!

# Водность текста – 0%
# Иваненко Павел Анатольевич. Место рождения – Иркутск. Образование – Национальный Исследовательский Иркутский государственный технический университет. Специальность - Конструкторско-технологическое обеспечение машиностроительных производств. Иностранные языки – французский, немецкий, английский. Любвеобилен. Характер – мягкий, податливый. Холост. Предпочитает интернет-общение. Носит одежду пастельных тонов. Злоупотребляет алкоголем. Коммуникабельный, ответственный, вежливый, доброжелательный, занудный.

# Попробуйте самостоятельно оценить водность следующего текста:
# Истинный ариец. Характер - нордический, выдержанный. С товарищами по работе поддерживает хорошие отношения. Безукоризненно выполняет свой служебный долг. Беспощаден к врагам Рейха. Отличный спортсмен: чемпион Берлина по теннису. Холост; в связях, порочащих его, замечен не был. Отмечен наградами фюрера и благодарностями рейхсфюрера СС.

# задача: разбить предложенный текст на слова, написав минимум кода. посторонние символы удалить. стоп-слова удалить. регулярные выражения использовать нельзя
# для простоты считаем, что у нас нет словаря стоп-слов, поэтому стоп-словами будем считать все слова короче 6 символов

text = "Вы должны войти в эту сеть перед тем как сможете получить доступ в Интернет. Этот сайт использует Форсированное защищённое соединение HTTP (HSTS), чтобы указать, что Firefox должен подключаться к нему только через защищённое соединение. В результате, добавление исключения для этого сертификата невозможно."

# избавляемся от прописных букв
text = text.lower()
# оставляем только слова на русском и английском языке. все лишние символы удаляем
text_that_matter = "".join(list(filter(lambda x: x>="а" and x<="я" or x>="a" and x<="z" or x == "ё" or x == " ", text)))
# разбиваем текст на слова
words = text_that_matter.split(" ")
# удаляем все слова короче 6 букв
words = list(filter(lambda x: len(x) > 5, words))
print(words)
